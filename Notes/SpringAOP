AOP
什么是动态代理？
在了解动态代理之前，我现在简单介绍下什么代理。代理：按照字面意思，就是代替你去做一些事情。代替你去完成一些功能，或者做一些本来应该你来做的事情。
这是字面意思理解，在面向对象的程序设计语言里：动态代理是在你原有的功能基础之上，对功能进行增强的一种实现手段。通过动态代理，并且符合开闭原则
的前提增强方法的功能。这也是AOP的思想，通过不修改原有代码，把你的代码织入到指定的方法中。

代理模式：
代理模式（Proxy）：为其他对象提供一个代理以控制对这个对象的访问。
主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（
比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，
我们可以在访问此对象时加上一个对此对象的访问层。

代理模式的元素是：共同接口、代理对象、目标对象。
代理模式的行为：由代理对象执行目标对象的方法、由代理对象扩展目标对象的方法。
代理模式的宏观特性：对客户端只暴露出接口，不暴露它以下的架构。

JDKProxDynameic 和 CGlibProxDynameic区别
jdk的动态代理是代理的接口，并且只能代理有 接口的类。如果这个类没有实现任何接口，jdk的动态代理是无法代理的。
这个时候就可以使用cglib去对类的字节码进行底层的继承代理，通过继承被代理对象。也就是JDKProxDynameic代理的接口CGlibProxDynameic代理的类
（如果类被final修饰就不能被代理成功）


AOP概念:面向切面编程,一种编程范式,知道开发者如何组织程序结构
->C语言是面向过程编程,Java是面向对象编程,这都是一种思想,一种编程形式

作用:在不惊动原始设计的基础上为其进行功能增强(不改方法的源代码却可以使用到其他方法的功能)    ->实现Spring倡导的:无入侵式编程

定义:我们在类里面实现的每一个功能(方法)叫做----------------------------------------------连接点
    如果我们将其他方法也需要的方法代码抽取出来做成一个方法去执行切入点,这个方法叫做-------------通知
    单独抽取出来的方法不能独立存在,所以我们要写一个类专门存放这种方法,类叫做------------------通知类
     那么这些被追加其他功能的方法叫做--------------------------------------------------切入点(一个或多个)
    通知肯定不止一个,那么如何确定通知与切入点的关系呢,这种关系叫做----------------------------切面


注意:AOP代理类不能通过其实现类获取Bean,应该通过其接口获取

AOP工作流程:(本质:代理模式)
1.Spring容器启动
2.0
3.初始化bean,判定bean对应的类中方法是否匹配到任意切入点    匹配失败->创建原始对象(匹配失败说明不需要增强，直接调用原始对象的方法即可)   /  匹配成功->创建原始对象(目标对象)的代理对象
4.获取bean执行方法  ->获取bean,调用方法并执行    *当获取的bean是代理对象时,根据代理对象的运行模式运行原始方法与增强的内容

AOP切入点表达式
                execution(void com.Zezai.dao.Dao.daoAction3(int a))
                           ↓         ↓         ↓              ↓
                     原始方法返回值   包名    接口/实现类      原始方法参数

                         可是,如果每一个切入点都写上这种表达式,过于繁琐
优化:使用通配符
    *表示单个独立任意符号    execution(* com.Zezai.dao.*.daoAction3(int a))
    ..表示多个任意符号      execution(* com.Zezai.*.*Service.save(..))  //表示增强com.Zezai包下所有Service的save方法


AOP通知类型
1.前置通知  @Before
2.后置通知  @After
3.环绕通知(*)   前后都执行
   @Around("pt()")
  public Object method(ProceedingJoinPoint pjp){ //如果没有使用该参数,将会直接跳过原始方法执行(不执行原始代码,而是执行通知的)
          System.out.println(before.....);
   Object ret=pjp.proceed();//在这个位置执行原方法(注意,proceed方法就是原方法,如果原方法有返回值,则该返回值就是proceed方法的返回值,记得最后要return给方法)
          System.out.println(after......);
                 return ret;
   }

如何从AOP里获取原始方法参数?
->之前我们已经知道了如何在AOP里获取原始方法的返回值(即pjp.proceed的返回值),那么如果原始方法需要参数,那么在AOP里怎么将这个参数传给它呢
方法:通过在AOP里传入JoinPoint对象,调用它的get.Arg();

